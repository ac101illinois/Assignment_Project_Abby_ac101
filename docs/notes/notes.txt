Ideas:
1. A Map that pinpoints each coffee shop on campus that a student could study at
2. A Rate/Review system so students can keep track of which spots they liked or did not like
3. A potential study page where lofi music plays while they work?

Wireframes:
- I sketched a menu page with an image of a coffee mug with a foam art location pointer in the middle, along with the rest of the pages at the top
- I made a frame for the map, and a search bar at the top
- I also made a page for users to go back to the shops they have visited before and see what their overall thoughts and rating were about the shop

Branching Strategy:
I decided on a GitHub branching strategy because it is best suited for a smaller team. Since it is just me working on this project, this simple, easy approach to branching will be best

Branch Usage Reflections:
Because I save and push my progress after every step, I did not realize we were supposed to wait until we created the new branch to push our wireframe pictures and notes. Therefore, I am not sure if that data ended up in the test branch. However, the process of creating and switching between branches was very smooth.

Django Set Up:
I used Assignment_Project_Abby_ac101 as my project folder name because that was what it automatically set to when I made this project. I tried changing it so it was differeny, but I had some problems pushing when that happened. I will seek help on how to successfully change the name of the folder.
Set up went very smooth, and I was able to open the link to my web application.

Virtual Environment:
I created a new virtual environment using the newest version of python. I did this so that there would be not interference between this project and my other project.

Assignment #3 Notes:

1. Why these models/fields?
Since this project is about students trying out difference coffee shops on campus and
reviewing them, I knew the main table needed to be students, and coffee shops needed
to be its own entity. I also decided to make the visits to the coffee shops an entity
to keep track of, and reviews as well.


2. Your relationship choices (ForeignKey, on_delete rationale)
Since Students are the main table, I knew the CoffeeShop table was going to be
a separate table. Students and CoffeeShop have a one-to-many relationship with Visits
because students can go to multiple coffee shops and coffee shops can have many visits,
but not the other way around. CoffeeShop has a one-to-many relationship with Reviews
because a coffee shop can have multiple reviews but not the other way around. And
Visits has a one-to-one relationship with Reviews because each visit should only have one
review, and each review should only be about one coffee shop.

For Foreign keys, I added PROTECT to the "student" and "shop" attributes in "Visit", and CASCADE to
the "visit" attribute in "Reviews". If a student or shop is deleted, the visits attached to
them will still exist, and if any visits are deleted, reviews attached to those visits
will also be deleted.

3. Any constraints (unique, ordering),
I added a unique restraint to the "Visit" class, so that a student can only have one visit per shop per day.
I also made it so that the visits will automatically be ordered by the date visited.


4. How you seeded test data.
I used the Admin panel to seed the test data, using the add/edit options to add the objects, and test out the
FKs I added.

Assignment #4
1. why you wrote two views
I wrote 3 different views due to the requirments of the assignment and presentation. I wrote a HttpResponse view
and a render view to practice with each and see how both differ in code.

2. whatâ€™s different between HttpResponse and render
A HttpResponse takes in a user request and sends raw output back to the user, without a template.
A render includes loading a template and context and filling it with the content the user is asking for.


3. any URL/template decisions you made.
For my templates, and made them all equal the html files for each view. With the url patterns, each path maps a
name for the site and links it the view I made for it, for example:
path('coffeeshops/', coffeeshop_list_render) --> the name 'coffeeshops' is the name for the site, and links it
with the coffee shop render view I made for it.

Assignment #5:
1. Difference between base CBVs and generic CBVs.
Base CBVs are inherited from Django's View class, and require the Http method using commands like .get() in
order to render the view. Generic CBVs are inherited from built-in views like ListView and DetailView.
Because they are built in, they require less code. One only needs to define the model, template and context
in order to create it.

2. Why generic views reduce boilerplate.
Generic views reduce the boilerplate because it requires less code and less information to be passed through.
Generic views are inherited from built-in views, so once the specific view is put in, a lot of the information
is filled in automatically.

3. Why refactoring URLs improves maintainability.
It improves the maintainability because if you refactor the URLS to the app urls.py as opposed to the project
urls.py, you are allowing the urls to be self-contained within the app as opposed to the project as a whole.
This allows the apps in the project to maintain their own urls and keep everything structured. It also makes
each page easier to navigate if they are within their own apps.

Assignment #6:
- Filtering is when a user puts in a query and gets information back that meets certain expectations. It also
filters through all the data (in my case list of visits) and brings back the information that meets the query
searched.
- The filter I used for this assignment is one to return the visitations that match the first name queried in the
search bar. For future versions of my view, I am going to add last name, date and coffee shop as things a user
can query so it is a more flexible search bar
- Aggregation, instead of filtering the data, summarizes it. It calculates certain numbers like totals and averages
(in my case, totals of each visits per student and coffee shop. It shows the count along with the name of the item
it is summarizing.
- My first summary is visits per student. This summarizes each student name and then shows how many coffee shop
visits they have individually made
- My second aggregation is visits per coffee shop. This summarizes each coffee shop name and shows how many visits
have been made to it.

Assignment #7:
- For static files in Django, specifically in the urls.py file, STATICFILES_DIRS and STATIC_URL are used to
access the static file, in my case the style.css file, so that the CSS customizations will show up when I try
to load them into my base.html fie.
- In order to load them in my base.html file, you have to add this line at the top of the file: {% laod static %}.
This loads the static files into your base template, and this way, the rest of your templates will have the
customizations if they extend the base.html file.
- The chart I created is a bar chart showcasing the number of coffee shop visits per each student. This is the
same for my aggregation at the bottom of the student_list page
- I used the ORM aggregation "Count" in order to count the number of visits per student.
- BytesIO is a class that generates images (png). I used this to generate the chart for my analytics page
- The tight_layout() function adjusts subplot spacing so nothing overlaps in your visualizations.

Assignment #8:
- A CSRF (Cross-Site Request Forgery) is an attack on a website when a malicious user pretends to be
 an authorized user.
- a csrf token is used to protect the website within the html file. This ensures the person using the
website is an authorized user and not a maliscious website/person trying to attack it.
- Some key steps in the form submission process is the user sending a post request, the form being validated,
the form being saved if it is or rendered again with error messages, and then afterward the user is redirected
to the previous page or given a success page
- FBVs are more simple and allow the user to make specific customizations, however it requires repetitive code
since there are no generic views (like CBV)
- CBVs include less/reusable code and are built-in views within django that use inheritance, however they do not
work well with complex views
- GET is used when a user wants to search/retrieve information from the website, q= in the url
- POST is used to update/change data within a website, and requires a csrf token for security

Assignment #9:
1. A JSON api is an endpoint which takes in a request and returns a formatted json response
2. Jsonresponses automatically serialize the data, and httpresponses require manually serializing the data, which
must be sent as a specified MIME type
3. My chart shows the amount of visits made to each coffee shop compared to the amount of long visits (over 60
minutes). The flow starts with my charts_visit_png view as the url path to the api, then fetches the json, counts
the amount of visits, creates the chart and then returns it as a png image.

Assignment #10:
- I picked the geocoding api called Nominatim, because it felt the most intuitive for my project. It would allow
the user of my website to search for different coffee shops in the Champaign, IL area.
- The fields I extracted for this api is the name of the cafe, the coordinated (latitude and longitude) and the
type of establishment (cafe)
-I limited the time it took to extract the data to be 5 minutes: "timeout=5", and used the raise_for_status()
function to make sure all the checks for the data were done successfully.
- The final JSON output displays the information from those fields I mentioned previously on the page, listed
out. It currently shows the user's current location.
- I noticed how searching for some of the coffee shops does not work, and I am still figuring out how to fix
it. I figure the search bar I created is accent sensitive, but there are other establishments, like Dunkin' on
Green Street, that is not showing up for me.

Assignment #11: Part 1
1. For the csv file, I created a httpresponse with the content type "text/csv", with fields Student, Shop,
Visit Date, and Study Duration(min)
2. For the json file, I serialized the data into a list of dictionaries and rendered a json response with the
fields student, shop, visit date, and study duration
3. On the reports page, I aggregated the amount of visits per each coffee shop, and the amount of minutes in
total spent at each coffee shop. Then, I gathered the total number of visits made across all the coffee shops.

Assignment #12: Part 2
1. Authentication matters because we don't want external users accessing other people's data and information
from our websites. We also don't want them to access admin pages that control the website and its features, it
should only be accessible to the team, and the other pages should only be acceptable to internal users
2. LoginRequiredMixin is a parameter that ensures class-based views are only able to be accessed by a user with
an account. @login_required is used in function-based views to only allow logged-in users access to those views
3. the next query parameter stores a redirect url for the page a user originally tried to access before they
signed up for the website. Once they do, they are taken to that original page
4. in settings, I created the login url, login redirect url, and the logout redirect url so it sends users to the
right page after those actions
5. Django's user model automatically sets a new user to not staff or super user once they sign up