Ideas:
1. A Map that pinpoints each coffee shop on campus that a student could study at
2. A Rate/Review system so students can keep track of which spots they liked or did not like
3. A potential study page where lofi music plays while they work?

Wireframes:
- I sketched a menu page with an image of a coffee mug with a foam art location pointer in the middle, along with the rest of the pages at the top
- I made a frame for the map, and a search bar at the top
- I also made a page for users to go back to the shops they have visited before and see what their overall thoughts and rating were about the shop

Branching Strategy:
I decided on a GitHub branching strategy because it is best suited for a smaller team. Since it is just me working on this project, this simple, easy approach to branching will be best

Branch Usage Reflections:
Because I save and push my progress after every step, I did not realize we were supposed to wait until we created the new branch to push our wireframe pictures and notes. Therefore, I am not sure if that data ended up in the test branch. However, the process of creating and switching between branches was very smooth.

Django Set Up:
I used Assignment_Project_Abby_ac101 as my project folder name because that was what it automatically set to when I made this project. I tried changing it so it was differeny, but I had some problems pushing when that happened. I will seek help on how to successfully change the name of the folder.
Set up went very smooth, and I was able to open the link to my web application.

Virtual Environment:
I created a new virtual environment using the newest version of python. I did this so that there would be not interference between this project and my other project.

Assignment #3 Notes:

1. Why these models/fields?
Since this project is about students trying out difference coffee shops on campus and
reviewing them, I knew the main table needed to be students, and coffee shops needed
to be its own entity. I also decided to make the visits to the coffee shops an entity
to keep track of, and reviews as well.


2. Your relationship choices (ForeignKey, on_delete rationale)
Since Students are the main table, I knew the CoffeeShop table was going to be
a separate table. Students and CoffeeShop have a one-to-many relationship with Visits
because students can go to multiple coffee shops and coffee shops can have many visits,
but not the other way around. CoffeeShop has a one-to-many relationship with Reviews
because a coffee shop can have multiple reviews but not the other way around. And
Visits has a one-to-one relationship with Reviews because each visit should only have one
review, and each review should only be about one coffee shop.

For Foreign keys, I added PROTECT to the "student" and "shop" attributes in "Visit", and CASCADE to
the "visit" attribute in "Reviews". If a student or shop is deleted, the visits attached to
them will still exist, and if any visits are deleted, reviews attached to those visits
will also be deleted.

3. Any constraints (unique, ordering),
I added a unique restraint to the "Visit" class, so that a student can only have one visit per shop per day.
I also made it so that the visits will automatically be ordered by the date visited.


4. How you seeded test data.
I used the Admin panel to seed the test data, using the add/edit options to add the objects, and test out the
FKs I added.

Assignment #4
1. why you wrote two views
I wrote 3 different views due to the requirments of the assignment and presentation. I wrote a HttpResponse view
and a render view to practice with each and see how both differ in code.

2. whatâ€™s different between HttpResponse and render
A HttpResponse takes in a user request and sends raw output back to the user, without a template.
A render includes loading a template and context and filling it with the content the user is asking for.


3. any URL/template decisions you made.
For my templates, and made them all equal the html files for each view. With the url patterns, each path maps a
name for the site and links it the view I made for it, for example:
path('coffeeshops/', coffeeshop_list_render) --> the name 'coffeeshops' is the name for the site, and links it
with the coffee shop render view I made for it.

Assignment #5:
1. Difference between base CBVs and generic CBVs.
Base CBVs are inherited from Django's View class, and require the Http method using commands like .get() in
order to render the view. Generic CBVs are inherited from built-in views like ListView and DetailView.
Because they are built in, they require less code. One only needs to define the model, template and context
in order to create it.

2. Why generic views reduce boilerplate.
Generic views reduce the boilerplate because it requires less code and less information to be passed through.
Generic views are inherited from built-in views, so once the specific view is put in, a lot of the information
is filled in automatically.

3. Why refactoring URLs improves maintainability.
It improves the maintainability because if you refactor the URLS to the app urls.py as opposed to the project
urls.py, you are allowing the urls to be self-contained within the app as opposed to the project as a whole.
This allows the apps in the project to maintain their own urls and keep everything structured. It also makes
each page easier to navigate if they are within their own apps.

Assignment #6:
- Filtering is when a user puts in a query and gets information back that meets certain expectations. It also
filters through all the data (in my case list of visits) and brings back the information that meets the query
searched.
- The filter I used for this assignment is one to return the visitations that match the first name queried in the
search bar. For future versions of my view, I am going to add last name, date and coffee shop as things a user
can query so it is a more flexible search bar
- Aggregation, instead of filtering the data, summarizes it. It calculates certain numbers like totals and averages
(in my case, totals of each visits per student and coffee shop. It shows the count along with the name of the item
it is summarizing.
- My first summary is visits per student. This summarizes each student name and then shows how many coffee shop
visits they have individually made
- My second aggregation is visits per coffee shop. This summarizes each coffee shop name and shows how many visits
have been made to it.

Assignment #7:
- For static files in Django, specifically in the urls.py file, STATICFILES_DIRS and STATIC_URL are used to
access the static file, in my case the style.css file, so that the CSS customizations will show up when I try
to load them into my base.html fie.
- In order to load them in my base.html file, you have to add this line at the top of the file: {% laod static %}.
This loads the static files into your base template, and this way, the rest of your templates will have the
customizations if they extend the base.html file.
- The chart I created is a bar chart showcasing the number of coffee shop visits per each student. This is the
same for my aggregation at the bottom of the student_list page
- I used the ORM aggregation "Count" in order to count the number of visits per student.
- BytesIO is a class that generates images (png). I used this to generate the chart for my analytics page
- The tight_layout() function adjusts subplot spacing so nothing overlaps in your visualizations.

Assignment #8:
- A CSRF (Cross-Site Request Forgery) is an attack on a website when a malicious user pretends to be
 an authorized user.
- a csrf token is used to protect the website within the html file. This ensures the person using the
website is an authorized user and not a maliscious website/person trying to attack it.
- Some key steps in the form submission process is the user sending a post request, the form being validated,
the form being saved if it is or rendered again with error messages, and then afterward the user is redirected
to the previous page or given a success page
- FBVs are more simple and allow the user to make specific customizations, however it requires repetitive code
since there are no generic views (like CBV)
- CBVs include less/reusable code and are built-in views within django that use inheritance, however they do not
work well with complex views
- GET is used when a user wants to search/retrieve information from the website, q= in the url
- POST is used to update/change data within a website, and requires a csrf token for security

Assignment #9:
1. A JSON api is an endpoint which takes in a request and returns a formatted json response
2. Jsonresponses automatically serialize the data, and httpresponses require manually serializing the data, which
must be sent as a specified MIME type
3. My chart shows the amount of visits made to each coffee shop compared to the amount of long visits (over 60
minutes). The flow starts with my charts_visit_png view as the url path to the api, then fetches the json, counts
the amount of visits, creates the chart and then returns it as a png image.